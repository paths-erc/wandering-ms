
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="description" content="Canvas Flowmap Layer with LeafletJS." />

  <title>Wandering manuscripts by PAThs</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3/dist/leaflet.css" />

  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      right: 0;
      left: 0;
    }
    #loading{
      text-align: center;
      margin: 0 auto;
      position: fixed; /* or absolute */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      color: #999;
      font-family: sans-serif;
    }
    #loading>img{
      vertical-align: middle;
    }
  </style>

</head>

<body>

  <div id="map">
    <div id="loading">
      <img class="alignnone" src="https://cdnjs.cloudflare.com/ajax/libs/galleriffic/2.0.1/css/loader.gif" alt="" width="48" height="48">
      Loading data from remote server&hellip;
    </div>
  </div>

  <!-- first load LeafletJS -->
  <script src="https://unpkg.com/leaflet@1.3/dist/leaflet.js"></script>

  <!-- load Esri Leaflet because we want to use an Esri basemap -->
  <script src="https://unpkg.com/esri-leaflet@2.1/dist/esri-leaflet.js"></script>

  <!-- load animation tweening lib requirement for CanvasFlowMapLayer -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.2.0/Tween.min.js"></script>

  <!-- then load CanvasFlowMapLayer -->
  <script src="https://jwasilgeo.github.io/Leaflet.Canvas-Flowmap-Layer/src/CanvasFlowmapLayer.js"></script>

  <script src="./formatGeoJson.js" charset="utf-8"></script>


  <script>

    const composeMap = (geoJsonFeatureCollection, places) => {
      document.getElementById('map').innerHTML = '';

      const bounds = [
        [
          31.331975179713332,
          39.91028308868409
        ],
        [
          24.003229109442877,
          24.089970588684086
        ]
      ];

      const esri = L.esri.basemapLayer('DarkGray');
      const imperium = L.tileLayer('http://dare.ht.lu.se/tiles/imperium/{z}/{x}/{y}.png');

      const baseMaps = {
        "Imperium": imperium,
        "Esri dark": esri
      }

      const map = L.map('map', {
        layers: [esri, imperium]
      });
      map.fitBounds(bounds);
      L.control.layers(baseMaps).addTo(map);

      var oneToManyFlowmapLayer = L.canvasFlowmapLayer(geoJsonFeatureCollection, {
        originAndDestinationFieldIds: {
          originUniqueIdField: 's_city_id',
          originGeometry: {
            x: 's_lon',
            y: 's_lat'
          },
          destinationUniqueIdField: 'e_city_id',
          destinationGeometry: {
            x: 'e_lon',
            y: 'e_lat'
          }
        },
        pathDisplayMode: 'selection',
        animationStarted: true,
        animationEasingFamily: 'Cubic',
        animationEasingType: 'In',
        animationDuration: 2000,

        canvasBezierStyle: {
            type: 'classBreaks',
            field: 'tot',
            classBreakInfos: [{
              classMinValue: 0,
              classMaxValue: 1,
              symbol: {
                strokeStyle: '#ff7b7b',
                lineWidth: 0.5
              }
            }, {
              classMinValue: 2,
              classMaxValue: 10,
              symbol: {
                strokeStyle: '#ff5252',
                lineWidth: 1.5
              }
            }, {
              classMinValue: 11,
              classMaxValue: 13,
              symbol: {
                strokeStyle: '#ff0000',
                lineWidth: 2.5
              }
            }, {
              classMinValue: 14,
              classMaxValue: 100,
              symbol: {
                strokeStyle: '#a70000',
                lineWidth: 3.5
              }
            }],
            defaultSymbol: {
              strokeStyle: '#ffbaba',
              lineWidth: 0.5
            },
          }


      }).addTo(map);
      oneToManyFlowmapLayer.getAnimationEasingOptions();

      oneToManyFlowmapLayer.on('click', function(e) {
        if (e.sharedOriginFeatures.length) {
          oneToManyFlowmapLayer.selectFeaturesForPathDisplay(e.sharedOriginFeatures, 'SELECTION_NEW');
        }
        if (e.sharedDestinationFeatures.length) {
          oneToManyFlowmapLayer.selectFeaturesForPathDisplay(e.sharedDestinationFeatures, 'SELECTION_NEW');
        }
      });

      places.forEach((p, i)=>{
        oneToManyFlowmapLayer.selectFeaturesForPathDisplayById('s_city_id', p, true, 'SELECTION_ADD');
      });

      const customControl =  L.Control.extend({
        options: {
          position: 'bottomright'
        },
        onAdd: function (map) {
          const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');

          container.style.backgroundColor = 'white';
          container.style.backgroundSize = "30px 30px";
          container.style.padding = ".5rem 1rem";
          container.innerHTML = `<div>
            <h2 style="margin:.5rem 0 1rem 0">Legend</h2>
            <div style="margin-bottom:.6rem; border-bottom:.5px solid #ff7b7b;">1</div>
            <div style="margin-bottom:.6rem; border-bottom:1.5px solid #ff5252;">2-10</div>
            <div style="margin-bottom:.6rem; border-bottom:2.5px solid #ff0000;">11-13</div>
            <div style="margin-bottom:.6rem; border-bottom:3.5px solid #a70000;">&gt;14</div>
          </div>`;

          return container;
        }
    });
    map.addControl(new customControl());

    };


    const apiUrl = "http://db.localhost/api/paths/m_msplaces?verb=search&type=encoded&join=+JOIN+paths__geodata+as+g+ON+g.id_link+%3D+place&fields[paths__m_msplaces.id_link]=id_link&fields[paths__m_msplaces.type]=Type&fields[paths__m_msplaces.place]=Place&fields[g.geometry]=geometry&limit_start=0&limit_end=500&q_encoded=IHBhdGhzX19tX21zcGxhY2VzLmlkX2xpbmsgSU4gKCBTRUxFQ1QgaWRfbGluayBGUk9NICBgcGF0aHNfX21fbXNwbGFjZXNgIEdST1VQIEJZIChpZF9saW5rKSBIQVZJTkcgQ09VTlQoRElTVElOQ1QgYHBsYWNlYCkgPiAxICkg";

    fetch(apiUrl).then( resp => {
      return resp.json();
    }).then( d => {
      const [geoJsonFeatureCollection, places] = formatGeoJson(d.records)
      composeMap(geoJsonFeatureCollection, places);
    }).catch( err => {
      console.log(JSON.stringify(err));
    });
  </script>

</body>

</html>
