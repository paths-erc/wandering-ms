
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="description" content="Canvas Flowmap Layer with LeafletJS." />

  <title>Canvas Flowmap Layer with LeafletJS</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3/dist/leaflet.css" />

  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      right: 0;
      left: 0;
    }
  </style>

</head>

<body>

  <div id="map">Loading data from remote server....</div>

  <!-- first load LeafletJS -->
  <script src="https://unpkg.com/leaflet@1.3/dist/leaflet.js"></script>

  <!-- load Esri Leaflet because we want to use an Esri basemap -->
  <script src="https://unpkg.com/esri-leaflet@2.1/dist/esri-leaflet.js"></script>

  <!-- load animation tweening lib requirement for CanvasFlowMapLayer -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.2.0/Tween.min.js"></script>

  <!-- then load CanvasFlowMapLayer -->
  <script src="https://jwasilgeo.github.io/Leaflet.Canvas-Flowmap-Layer/src/CanvasFlowmapLayer.js"></script>

  <script src="formatGeoJson.js" charset="utf-8"></script>


  <script>

    const composeMap = (geoJsonFeatureCollection, places) => {

      const bounds = [
        [
          31.331975179713332,
          39.91028308868409
        ],
        [
          24.003229109442877,
          24.089970588684086
        ]
      ];

      const esri = L.esri.basemapLayer('DarkGray');
      const imperium = L.tileLayer('http://dare.ht.lu.se/tiles/imperium/{z}/{x}/{y}.png');

      const baseMaps = {
        "Imperium": imperium,
        "Esri dark": esri
      }

      const map = L.map('map', {
        layers: [esri, imperium]
      });
      map.fitBounds(bounds);
      L.control.layers(baseMaps).addTo(map);

      var oneToManyFlowmapLayer = L.canvasFlowmapLayer(geoJsonFeatureCollection, {
        originAndDestinationFieldIds: {
          originUniqueIdField: 's_city_id',
          originGeometry: {
            x: 's_lon',
            y: 's_lat'
          },
          destinationUniqueIdField: 'e_city_id',
          destinationGeometry: {
            x: 'e_lon',
            y: 'e_lat'
          }
        },
        pathDisplayMode: 'selection',
        animationStarted: true,
        animationEasingFamily: 'Cubic',
        animationEasingType: 'In',
        animationDuration: 2000
      }).addTo(map);
      oneToManyFlowmapLayer.getAnimationEasingOptions();

      oneToManyFlowmapLayer.on('click', function(e) {
        if (e.sharedOriginFeatures.length) {
          oneToManyFlowmapLayer.selectFeaturesForPathDisplay(e.sharedOriginFeatures, 'SELECTION_NEW');
        }
        if (e.sharedDestinationFeatures.length) {
          oneToManyFlowmapLayer.selectFeaturesForPathDisplay(e.sharedDestinationFeatures, 'SELECTION_NEW');
        }
      });

      places.forEach((p, i)=>{
        oneToManyFlowmapLayer.selectFeaturesForPathDisplayById('s_city_id', p, true, 'SELECTION_ADD');
      });
    };




    // composeMap([], []);

    const apiUrl = "http://db.localhost/api/paths/m_msplaces?verb=search&type=encoded&join=+JOIN+paths__geodata+as+g+ON+g.id_link+%3D+place&fields[paths__m_msplaces.id_link]=id_link&fields[paths__m_msplaces.type]=Type&fields[paths__m_msplaces.place]=Place&fields[g.geometry]=geometry&limit_start=0&limit_end=500&q_encoded=IHBhdGhzX19tX21zcGxhY2VzLmlkX2xpbmsgSU4gKCBTRUxFQ1QgaWRfbGluayBGUk9NICBgcGF0aHNfX21fbXNwbGFjZXNgIEdST1VQIEJZIChpZF9saW5rKSBIQVZJTkcgQ09VTlQoRElTVElOQ1QgYHBsYWNlYCkgPiAxICkg";

    fetch(apiUrl).then( resp => {
      return resp.json();
    }).then( d => {
      const [geoJsonFeatureCollection, places] = formatGeoJson(d.records)
      composeMap(geoJsonFeatureCollection, places);
    }).catch( err => {
      console.log(JSON.stringify(err));
    });
  </script>

</body>

</html>
